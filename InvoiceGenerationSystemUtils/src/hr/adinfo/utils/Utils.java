/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package hr.adinfo.utils;

import hr.adinfo.utils.communication.ServerResponse;
import hr.adinfo.utils.communication.ServerQuery;
import hr.adinfo.utils.database.DatabaseQueryResult;
import hr.adinfo.utils.database.DatabaseQuery;
import hr.adinfo.utils.communication.ExecuteQueryInterface;
import hr.adinfo.utils.communication.ServerQueryTask;
import hr.adinfo.utils.communication.ServerResponseList;
import hr.adinfo.utils.database.DatabaseDiff;
import hr.adinfo.utils.database.DatabaseDiffQuery;
import hr.adinfo.utils.database.DatabaseDiffResponse;
import hr.adinfo.utils.database.DatabaseQueryResponse;
import hr.adinfo.utils.database.MultiDatabaseQuery;
import hr.adinfo.utils.database.MultiDatabaseQueryInsertLocalInvoice;
import java.awt.Component;
import java.awt.Container;
import java.awt.Window;
import java.awt.event.KeyListener;
import java.beans.PropertyChangeListener;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.Properties;
import java.util.concurrent.ExecutionException;
import javax.swing.JDialog;

/**
 *
 * @author Matej
 */
public class Utils {
	public static DatabaseQueryResult ExecuteDatabaseQuery(Connection connection, DatabaseQuery databaseQuery, final Object lock) throws SQLException, UnknownHostException {
		DatabaseQueryResult databaseQueryResult = new DatabaseQueryResult();
		PreparedStatement preparedStatement = connection.prepareStatement(databaseQuery.query);
		preparedStatement.setQueryTimeout(databaseQuery.timeoutSeconds);
		ResultSet resultSet = null;
		
		for (Pair<Integer, String> param : databaseQuery.params) {
			preparedStatement.setString(param.getKey(), param.getValue());
		}
		for (Pair<Integer, byte[]> param : databaseQuery.paramsBytes) {
			preparedStatement.setBytes(param.getKey(), param.getValue());
		}
		
		if(databaseQuery.autoIncrementParam != null && databaseQuery.autoIncrementTable != null){
			// Auto increment block
			synchronized(lock){
				int maxID = -1;
				String tableName = databaseQuery.autoIncrementTable;
				String columnName = databaseQuery.autoIncrementParam.getValue();
				if(tableName.trim().contains(" ")){
					tableName = "";
				}
				if(columnName.trim().contains(" ")){
					columnName = "";
				}
				
				String query = "SELECT MAX(" + columnName + ") FROM " + tableName;
				PreparedStatement ps = connection.prepareStatement(query);
				ps.setMaxRows(1);
				ResultSet result = ps.executeQuery();
				if (result.next()) {
					maxID = result.getInt(1);
				}

				preparedStatement.setInt(databaseQuery.autoIncrementParam.getKey(), maxID + 1);
				databaseQueryResult.autoGeneratedKey = maxID + 1;

				if("SELECT".equals(databaseQuery.query.toUpperCase().substring(0, 6))){
					resultSet = preparedStatement.executeQuery();
				} else {
					preparedStatement.executeUpdate();
				}
			}
		} else {
			// Single query block
			if("SELECT".equals(databaseQuery.query.toUpperCase().substring(0, 6))){
				resultSet = preparedStatement.executeQuery();
			} else {
				preparedStatement.executeUpdate();
			}
		}
		
		while (resultSet != null && resultSet.next()) {
			Object[] row = new Object[resultSet.getMetaData().getColumnCount()];
			for(int i = 0; i < resultSet.getMetaData().getColumnCount(); ++i){
				row[i] = resultSet.getObject(i+1);
			}
			databaseQueryResult.add(row);
		}
		return databaseQueryResult;
	}
	
	public static ServerResponse ExecuteRemoteQuery(ServerQuery serverQuery, Socket clientSocket, ObjectOutputStream oos, ServerResponseList serverResponseList) throws IOException, InterruptedException{
		if(!IsSocketValid(clientSocket)){
			ServerResponse serverResponse = new ServerResponse(serverQuery);
			serverResponse.errorCode = Values.RESPONSE_ERROR_CODE_CONNECTION_FAILED;
			return serverResponse;
		}
		
		oos.writeObject(serverQuery);
		oos.flush();
		
		int timeout = 1000 * serverQuery.timeoutSeconds;
		int delay = 50;
		int counter = 0;
		while(counter < timeout){
			counter += delay;
			Thread.sleep(delay);
			
			ServerResponse serverResponseFound = serverResponseList.GetResponseByQueryId(serverQuery.queryId);
			if(serverResponseFound != null){
				serverResponseList.RemoveResponse(serverResponseFound);
				return serverResponseFound;
			}
		}
		
		return null;
	}
	
	public static DatabaseQueryResult MasterExecuteDatabaseQuery(Connection connection, DatabaseQuery databaseQuery, final Object lock) throws SQLException, UnknownHostException, IOException {
		DatabaseQueryResult databaseQueryResult = new DatabaseQueryResult();
		PreparedStatement preparedStatement = connection.prepareStatement(databaseQuery.query);
		preparedStatement.setQueryTimeout(databaseQuery.timeoutSeconds);
		ResultSet resultSet = null;
		
		for (Pair<Integer, String> param : databaseQuery.params) {
			preparedStatement.setString(param.getKey(), param.getValue());
		}
		for (Pair<Integer, byte[]> param : databaseQuery.paramsBytes) {
			preparedStatement.setBytes(param.getKey(), param.getValue());
		}
		
		DatabaseDiff databaseDiff = new DatabaseDiff(databaseQuery);
		PreparedStatement diffPreparedStatement = connection.prepareStatement("INSERT INTO DIFF_TABLE (ID, DIFF) VALUES (?, ?)");
		PreparedStatement localValuesPreparedStatement = connection.prepareStatement("UPDATE LOCAL_VALUES_TABLE SET VALUE = ? WHERE NAME = 'lastDiffId'");
		
		synchronized(lock){
			// Auto increment block
			if(databaseQuery.autoIncrementParam != null && databaseQuery.autoIncrementTable != null){
				int maxID = -1;
				String tableName = databaseQuery.autoIncrementTable;
				String columnName = databaseQuery.autoIncrementParam.getValue();
				if(tableName.trim().contains(" ")){
					tableName = "";
				}
				if(columnName.trim().contains(" ")){
					columnName = "";
				}
				
				String query = "SELECT MAX(" + columnName + ") FROM " + tableName;
				PreparedStatement ps = connection.prepareStatement(query);
				ps.setMaxRows(1);
				ResultSet result = ps.executeQuery();
				if (result.next()) {
					maxID = result.getInt(1);
				}

				preparedStatement.setInt(databaseQuery.autoIncrementParam.getKey(), maxID + 1);
				databaseDiff.AddParam(databaseQuery.autoIncrementParam.getKey(), maxID + 1);
				databaseQueryResult.autoGeneratedKey = maxID + 1;
			}
			
			// Auto increment block DIFF_TABLE
			{
				/*int maxID = -1;
				String query = "SELECT MAX(ID) FROM DIFF_TABLE";
				PreparedStatement ps = connection.prepareStatement(query);
				ps.setMaxRows(1);
				ResultSet result = ps.executeQuery();
				if (result.next()) {
					maxID = result.getInt(1);
				}*/
				
				int lastDiffId = -1;
				String query2 = "SELECT VALUE FROM LOCAL_VALUES_TABLE WHERE NAME = 'lastDiffId' FETCH FIRST ROW ONLY";
				PreparedStatement ps2 = connection.prepareStatement(query2);
				ps2.setMaxRows(1);
				ResultSet result2 = ps2.executeQuery();
				if (result2.next()) {
					lastDiffId = result2.getInt(1);
				}
				
				/*if(maxID != lastDiffId){
					throw new SQLException("Master out of sync! (diff table max id != last diff id) " + maxID + " != " + lastDiffId);
				}*/
				
				diffPreparedStatement.setInt(1, lastDiffId + 1);
				localValuesPreparedStatement.setInt(1, lastDiffId + 1);
				databaseDiff.diffId = lastDiffId + 1;
			}
			
			if("SELECT".equals(databaseQuery.query.toUpperCase().substring(0, 6))){
				resultSet = preparedStatement.executeQuery();
			} else {
				diffPreparedStatement.setBytes(2, Utils.SerializeObject(databaseDiff));
				try {
					connection.setAutoCommit(false);

					preparedStatement.executeUpdate();
					diffPreparedStatement.executeUpdate();
					localValuesPreparedStatement.executeUpdate();
							
					connection.commit();
				} catch (SQLException ex){
					try {
						connection.rollback();
					} catch (SQLException ex2){}
					
					throw ex;
				} finally {
					try {
						connection.setAutoCommit(true);
					} catch (SQLException ex2){}
				}
			}
		}
		
		while (resultSet != null && resultSet.next()) {
			Object[] row = new Object[resultSet.getMetaData().getColumnCount()];
			for(int i = 0; i < resultSet.getMetaData().getColumnCount(); ++i){
				row[i] = resultSet.getObject(i+1);
			}
			databaseQueryResult.add(row);
		}
		
		// Cleanup
		try {
			if(resultSet != null)
				resultSet.close();
		} catch (SQLException e){ }
		
		return databaseQueryResult;
	}
	
	public static DatabaseQueryResult[] MasterExecuteMultiDatabaseQuery(Connection connection, MultiDatabaseQuery multiDatabaseQuery, final Object lock) throws SQLException, UnknownHostException, IOException {
		if(multiDatabaseQuery instanceof MultiDatabaseQueryInsertLocalInvoice){
			MultiDatabaseQueryInsertLocalInvoice multiDatabaseQueryInsertLocalInvoice = (MultiDatabaseQueryInsertLocalInvoice)multiDatabaseQuery;
			
			String query = "SELECT ID FROM INVOICES WHERE O_NUM = ? AND CR_NUM = ? AND I_NUM = ? AND SPEC_NUM = ? AND YEAR(I_DATE) = ?";
			if(multiDatabaseQueryInsertLocalInvoice.specNum != 0){
				query = "SELECT ID FROM INVOICES WHERE O_NUM = ? AND CR_NUM = ? AND I_NUM = ? AND SPEC_NUM = ? AND YEAR(I_DATE) = ? AND PAY_TYPE = ?";
			}
			if(multiDatabaseQueryInsertLocalInvoice.isTest){
				query = query.replace("INVOICES", "INVOICES_TEST");
			}
			PreparedStatement ps = connection.prepareStatement(query);
			ps.setInt(1, multiDatabaseQueryInsertLocalInvoice.oNum);
			ps.setInt(2, multiDatabaseQueryInsertLocalInvoice.crNum);
			ps.setInt(3, multiDatabaseQueryInsertLocalInvoice.iNum );
			ps.setInt(4, multiDatabaseQueryInsertLocalInvoice.specNum);
			ps.setInt(5, multiDatabaseQueryInsertLocalInvoice.iYear);
			if (multiDatabaseQueryInsertLocalInvoice.specNum != 0){
				ps.setInt(6, multiDatabaseQueryInsertLocalInvoice.payType);
			}
			ps.setMaxRows(1);
			ResultSet result = ps.executeQuery();
			if (result.next()) {
				return null;
			}
		}
		
		DatabaseQueryResult[] databaseQueryResults = new DatabaseQueryResult[multiDatabaseQuery.querySize];
		PreparedStatement[] preparedStatements = new PreparedStatement[multiDatabaseQuery.querySize];
		PreparedStatement[] diffPreparedStatements = new PreparedStatement[multiDatabaseQuery.querySize];
		PreparedStatement[] localValuesPreparedStatements = new PreparedStatement[multiDatabaseQuery.querySize];
		DatabaseDiff[] databaseDiffs = new DatabaseDiff[multiDatabaseQuery.querySize];
		ResultSet[] resultSets = new ResultSet[multiDatabaseQuery.querySize];
		
		for(int i = 0; i < databaseQueryResults.length; ++i){
			databaseQueryResults[i] = new DatabaseQueryResult();
			
			preparedStatements[i] = connection.prepareStatement(multiDatabaseQuery.query[i]);
			preparedStatements[i].setQueryTimeout(multiDatabaseQuery.timeoutSeconds);

			for (Pair<Integer, String> param : multiDatabaseQuery.params[i]) {
				preparedStatements[i].setString(param.getKey(), param.getValue());
			}
			for (Pair<Integer, byte[]> param : multiDatabaseQuery.paramsBytes[i]) {
				preparedStatements[i].setBytes(param.getKey(), param.getValue());
			}

			databaseDiffs[i] = new DatabaseDiff(multiDatabaseQuery, i);
			diffPreparedStatements[i] = connection.prepareStatement("INSERT INTO DIFF_TABLE (ID, DIFF) VALUES (?, ?)");
			localValuesPreparedStatements[i] = connection.prepareStatement("UPDATE LOCAL_VALUES_TABLE SET VALUE = ? WHERE NAME = 'lastDiffId'");
		}
		
		synchronized(lock){
			int loopCounter = 0;
			try {
				connection.setAutoCommit(false);
				for (int i = 0; i < databaseQueryResults.length; ++i){
					loopCounter = i;
					
					// Auto increment block
					if(multiDatabaseQuery.autoIncrementParam[i] != null && multiDatabaseQuery.autoIncrementTable[i] != null){
						int maxID = -1;
						String tableName = multiDatabaseQuery.autoIncrementTable[i];
						String columnName = multiDatabaseQuery.autoIncrementParam[i].getValue();
						if(tableName.trim().contains(" ")){
							tableName = "";
						}
						if(columnName.trim().contains(" ")){
							columnName = "";
						}
				
						String query = "SELECT MAX(" + columnName + ") FROM " + tableName;
						PreparedStatement ps = connection.prepareStatement(query);
						ps.setMaxRows(1);
						ResultSet result = ps.executeQuery();
						if (result.next()) {
							maxID = result.getInt(1);
						}

						preparedStatements[i].setInt(multiDatabaseQuery.autoIncrementParam[i].getKey(), maxID + 1);
						databaseDiffs[i].AddParam(multiDatabaseQuery.autoIncrementParam[i].getKey(), maxID + 1);
						databaseQueryResults[i].autoGeneratedKey = maxID + 1;
					}

					// Auto generated values block
					for (Pair<Integer, Integer> autoGeneratedParam : multiDatabaseQuery.autoGeneratedParams[i]) {
						int generatedParamQueryId = autoGeneratedParam.getValue();
						preparedStatements[i].setInt(autoGeneratedParam.getKey(), databaseQueryResults[generatedParamQueryId].autoGeneratedKey);
						databaseDiffs[i].AddParam(autoGeneratedParam.getKey(), databaseQueryResults[generatedParamQueryId].autoGeneratedKey);
					}

					// Auto increment block DIFF_TABLE
					{
						int lastDiffId = -1;
						String query2 = "SELECT VALUE FROM LOCAL_VALUES_TABLE WHERE NAME = 'lastDiffId' FETCH FIRST ROW ONLY";
						PreparedStatement ps2 = connection.prepareStatement(query2);
						ps2.setMaxRows(1);
						ResultSet result2 = ps2.executeQuery();
						if (result2.next()) {
							lastDiffId = result2.getInt(1);
						}

						/*if(maxID != lastDiffId){
							throw new SQLException("Master out of sync! (diff table max id != last diff id) " + maxID + " != " + lastDiffId);
						}*/

						diffPreparedStatements[i].setInt(1, lastDiffId + 1);
						localValuesPreparedStatements[i].setInt(1, lastDiffId + 1);
						databaseDiffs[i].diffId = lastDiffId + 1;
					}

					if("SELECT".equals(multiDatabaseQuery.query[i].toUpperCase().substring(0, 6))){
						resultSets[i] = preparedStatements[i].executeQuery();
					} else {
						diffPreparedStatements[i].setBytes(2, Utils.SerializeObject(databaseDiffs[i]));
						
						preparedStatements[i].executeUpdate();
						diffPreparedStatements[i].executeUpdate();
						localValuesPreparedStatements[i].executeUpdate();
					}
				}
			} catch (SQLException ex){
				connection.rollback();
				if (loopCounter < multiDatabaseQuery.params.length && loopCounter < multiDatabaseQuery.query.length){
					String queryParams = "";
					for (Pair<Integer, String> param : multiDatabaseQuery.params[loopCounter]) {
						queryParams += param.getValue() + ", ";
					}
					throw new SQLException("Error on query with ID " + loopCounter + ": " 
							+ System.lineSeparator() + multiDatabaseQuery.query[loopCounter] 
							+ System.lineSeparator() + queryParams 
							+ System.lineSeparator() + ex.getMessage()
							+ System.lineSeparator(), ex);
				} else {
					throw ex;
				}
			} finally {
				connection.setAutoCommit(true);
			}
		}
		for(int i = 0; i < databaseQueryResults.length; ++i){
			while (resultSets[i] != null && resultSets[i].next()) {
				Object[] row = new Object[resultSets[i].getMetaData().getColumnCount()];
				for(int j = 0; j < resultSets[i].getMetaData().getColumnCount(); ++j){
					row[j] = resultSets[i].getObject(j+1);
				}
				databaseQueryResults[i].add(row);
			}

			// Cleanup
			try {
				if(resultSets[i] != null)
					resultSets[i].close();
			} catch (SQLException e){ }
		}
		
		return databaseQueryResults;
	}
	
	public static DatabaseQueryResult[] ExecuteMultiDatabaseQuery(Connection connection, MultiDatabaseQuery multiDatabaseQuery, final Object lock) throws SQLException, UnknownHostException, IOException {
		DatabaseQueryResult[] databaseQueryResults = new DatabaseQueryResult[multiDatabaseQuery.querySize];
		PreparedStatement[] preparedStatements = new PreparedStatement[multiDatabaseQuery.querySize];
		ResultSet[] resultSets = new ResultSet[multiDatabaseQuery.querySize];
		
		for(int i = 0; i < databaseQueryResults.length; ++i){
			databaseQueryResults[i] = new DatabaseQueryResult();
			
			preparedStatements[i] = connection.prepareStatement(multiDatabaseQuery.query[i]);
			preparedStatements[i].setQueryTimeout(multiDatabaseQuery.timeoutSeconds);

			for (Pair<Integer, String> param : multiDatabaseQuery.params[i]) {
				preparedStatements[i].setString(param.getKey(), param.getValue());
			}
			for (Pair<Integer, byte[]> param : multiDatabaseQuery.paramsBytes[i]) {
				preparedStatements[i].setBytes(param.getKey(), param.getValue());
			}
		}
		
		synchronized(lock){
			try {
				connection.setAutoCommit(false);

				for(int i = 0; i < databaseQueryResults.length; ++i){
					// Auto increment block
					if(multiDatabaseQuery.autoIncrementParam[i] != null && multiDatabaseQuery.autoIncrementTable[i] != null){
						int maxID = -1;
						String tableName = multiDatabaseQuery.autoIncrementTable[i];
						String columnName = multiDatabaseQuery.autoIncrementParam[i].getValue();
						if(tableName.trim().contains(" ")){
							tableName = "";
						}
						if(columnName.trim().contains(" ")){
							columnName = "";
						}
				
						String query = "SELECT MAX(" + columnName + ") FROM " + tableName;
						PreparedStatement ps = connection.prepareStatement(query);
						ps.setMaxRows(1);
						ResultSet result = ps.executeQuery();
						if (result.next()) {
							maxID = result.getInt(1);
						}

						preparedStatements[i].setInt(multiDatabaseQuery.autoIncrementParam[i].getKey(), maxID + 1);
						databaseQueryResults[i].autoGeneratedKey = maxID + 1;
					}

					// Auto generated values block
					for (Pair<Integer, Integer> autoGeneratedParam : multiDatabaseQuery.autoGeneratedParams[i]) {
						int generatedParamQueryId = autoGeneratedParam.getValue();
						preparedStatements[i].setInt(autoGeneratedParam.getKey(), databaseQueryResults[generatedParamQueryId].autoGeneratedKey);
					}

					if("SELECT".equals(multiDatabaseQuery.query[i].toUpperCase().substring(0, 6))){
						resultSets[i] = preparedStatements[i].executeQuery();
					} else {
						preparedStatements[i].executeUpdate();
					}
				}
			} catch (SQLException ex){
				connection.rollback();
				throw ex;
			} finally {
				connection.setAutoCommit(true);
			}
		}
		for(int i = 0; i < databaseQueryResults.length; ++i){
			while (resultSets[i] != null && resultSets[i].next()) {
				Object[] row = new Object[resultSets[i].getMetaData().getColumnCount()];
				for(int j = 0; j < resultSets[i].getMetaData().getColumnCount(); ++j){
					row[j] = resultSets[i].getObject(j+1);
				}
				databaseQueryResults[i].add(row);
			}

			// Cleanup
			try {
				if(resultSets[i] != null)
					resultSets[i].close();
			} catch (SQLException e){ }
		}
		
		return databaseQueryResults;
	}
	
	public static DatabaseDiffResponse ExecuteDatabaseDiffQuery(Connection connection, DatabaseDiffQuery databaseDiffQuery) throws Exception {
		String query = "SELECT DIFF FROM DIFF_TABLE WHERE ID BETWEEN ? AND ? ORDER BY ID";
		PreparedStatement preparedStatement = connection.prepareStatement(query);
		preparedStatement.setInt(1, databaseDiffQuery.lastDiffId + 1);
		preparedStatement.setInt(2, databaseDiffQuery.lastDiffId + 1 + Values.LOCAL_SERVER_DIFF_SYNC_MAX_ROWS);
		preparedStatement.setQueryTimeout(databaseDiffQuery.timeoutSeconds);
		ResultSet resultSet = preparedStatement.executeQuery();
		
		DatabaseDiffResponse databaseDiffResponse = new	DatabaseDiffResponse(databaseDiffQuery);
		while (resultSet != null && resultSet.next()) {
			byte[] bytes = resultSet.getBytes(1);
			DatabaseDiff databaseDiff = (DatabaseDiff ) Utils.DeserializeObject(bytes);
			databaseDiffResponse.diffList.add(databaseDiff);
		}
		
		int lastDiffId = databaseDiffQuery.lastDiffId;
		if(databaseDiffResponse.diffList.size() > Values.LOCAL_SERVER_DIFF_SYNC_MAX_DIALOG_ROWS){
			String queryLastDiffId = "SELECT VALUE FROM LOCAL_VALUES_TABLE WHERE NAME = 'lastDiffId' FETCH FIRST ROW ONLY";
			PreparedStatement psLastDiffId = connection.prepareStatement(queryLastDiffId);
			psLastDiffId.setMaxRows(1);
			ResultSet resultLastDiffId = psLastDiffId.executeQuery();
			if (resultLastDiffId.next()) {
				lastDiffId = resultLastDiffId.getInt(1);
			}
		}
		
		databaseDiffResponse.maxDiffId = lastDiffId;
		
		return databaseDiffResponse;
	}
	
	public static void LocalServerInsertDatabaseDiff(Connection connection, DatabaseDiff databaseDiff, final Object lock) throws Exception {
		// Create main query
		boolean skipQuery = false;
		PreparedStatement preparedStatement = connection.prepareStatement(databaseDiff.query);		
		for (Pair<Integer, String> param : databaseDiff.params) {
			// TODO remove ifs
			if(databaseDiff.query.contains("INSERT INTO RECEIPTS") && (param.getKey() == 2 || param.getKey() == 6) && param.getValue().equals("1.1.2020.")){
				preparedStatement.setString(param.getKey(), "2020-01-01");
			} else if(databaseDiff.query.contains("INSERT INTO TAX_RATES") && param.getKey() == 1 && param.getValue().equals("3")){
				skipQuery = true;
			} else {
				preparedStatement.setString(param.getKey(), param.getValue());
			}
			
			//preparedStatement.setString(param.getKey(), param.getValue());
		}
		for (Pair<Integer, byte[]> param : databaseDiff.paramsBytes) {
			preparedStatement.setBytes(param.getKey(), param.getValue());
		}
		
		// Create diff table insert query
		PreparedStatement diffPreparedStatement = connection.prepareStatement("INSERT INTO DIFF_TABLE (ID, DIFF) VALUES (?, ?)");
		diffPreparedStatement.setInt(1, databaseDiff.diffId);
		diffPreparedStatement.setBytes(2, Utils.SerializeObject(databaseDiff));
		
		// Create local values update query
		PreparedStatement localValuesPreparedStatement = connection.prepareStatement("UPDATE LOCAL_VALUES_TABLE SET VALUE = ? WHERE NAME = 'lastDiffId'");
		localValuesPreparedStatement.setInt(1, databaseDiff.diffId);
		
		synchronized(lock){
			// Auto increment block DIFF_TABLE
			{
				int lastDiffId = -1;
				String query2 = "SELECT VALUE FROM LOCAL_VALUES_TABLE WHERE NAME = 'lastDiffId' FETCH FIRST ROW ONLY";
				PreparedStatement ps2 = connection.prepareStatement(query2);
				ps2.setMaxRows(1);
				ResultSet result2 = ps2.executeQuery();
				if (result2.next()) {
					lastDiffId = result2.getInt(1);
				}
				
				if(databaseDiff.diffId != lastDiffId + 1){
					throw new SQLException("Wrong diff sent to sync! (databaseDiff.diffId != lastDiffId + 1) " + databaseDiff.diffId + " != " + (lastDiffId + 1));
				}
			}
			
			try {
				connection.setAutoCommit(false);

				if(!skipQuery){
					preparedStatement.executeUpdate();
				}
				diffPreparedStatement.executeUpdate();
				localValuesPreparedStatement.executeUpdate();

				connection.commit();
			} catch (SQLException ex){
				try {
					connection.rollback();
				} catch (SQLException ex2){}

				throw ex;
			} finally {
				try {
					connection.setAutoCommit(true);
				} catch (SQLException ex2){}
			}
		}
	}
	
	public static boolean GetIsInVATSystem(ExecuteQueryInterface executeQueryInterface, LoggerInterface printLogInterface){
		final JDialog loadingDialog = new LoadingDialog(null, true);
		
		DatabaseQuery databaseQuery = new DatabaseQuery("SELECT VALUE FROM GLOBAL_VALUES_TABLE WHERE NAME = 'VATSystem' FETCH FIRST ROW ONLY");
		ServerQueryTask databaseQueryTask = new ServerQueryTask(loadingDialog, databaseQuery, executeQueryInterface, printLogInterface);

		databaseQueryTask.execute();
		loadingDialog.setVisible(true);
		if(!databaseQueryTask.isDone()){
			databaseQueryTask.cancel(true);
		} else {
			try {
				ServerResponse serverResponse = databaseQueryTask.get();
				DatabaseQueryResult databaseQueryResult = null;
				if(serverResponse != null && serverResponse.errorCode == Values.RESPONSE_ERROR_CODE_SUCCESS){
					databaseQueryResult = ((DatabaseQueryResponse) serverResponse).databaseQueryResult;
				}
				if(databaseQueryResult != null){
					if (databaseQueryResult.next()) {
						int value = databaseQueryResult.getInt(0);
						if(value == 0){
							return false;
						} else {
							return true;
						}
					}
				}
			} catch (InterruptedException | ExecutionException ex) {
				printLogInterface.ShowErrorLog(ex);
			}
		}
		
		return true;
	}
	
	public static ServerSocket CheckMultipleInstances(int portNumber){
		ServerSocket socketLock = null;
		try {
			socketLock = new ServerSocket();
			socketLock.bind(new InetSocketAddress(portNumber));
		} catch (IOException ex) {
			
		}
		
		return socketLock;
	}
	
	public static Connection getDatabaseConnection(String address, int port, String dbName) throws UnknownHostException, SQLException{
		// TODO
		/* Note that user authentication is off by default, meaning that any
		 * user can connect to your database using any password. To enable
		 * authentication, see the Derby Developer's Guide.
		 */

		Properties properties = new Properties();
		properties.put("user", "user1");
		properties.put("password", "user1");

		return DriverManager.getConnection(Values.DATABASE_PROTOCOL + address + ":" + port + "/" + dbName + ";create=true", properties);
	}
	
	public static boolean IsSocketValid(Socket socket){
		if(socket == null)
			return false;
		
		if(!socket.isConnected() || socket.isClosed())
			return false;
		
		if(socket.isInputShutdown())
			return false;
		
		if(socket.isOutputShutdown())
			return false;
		
		return true;
	}
	
	public static void DisposeDialog(Window dialog){
		List<Component> compList = GetAllComponents(dialog);
		for (Component comp : compList) {
			for (PropertyChangeListener listener : comp.getPropertyChangeListeners()) {
				comp.removePropertyChangeListener(listener);
			}
			for (KeyListener listener : comp.getKeyListeners()) {
				comp.removeKeyListener(listener);
			}
			// TODO add other listeners (actionPerformed, ItemStateChanged...)
		}
		
		java.awt.EventQueue.invokeLater(new Runnable() {
			@Override
			public void run() {
				dialog.dispose();
			}
		});
	}
	
	public static List<Component> GetAllComponents(final Container c) {
		Component[] comps = c.getComponents();
		List<Component> compList = new ArrayList<Component>();
		for (Component comp : comps) {
			compList.add(comp);
			if (comp instanceof Container){
				compList.addAll(GetAllComponents((Container) comp));
			}
		}
		return compList;
	}
	
	public static byte[] SerializeObject(Object object) throws IOException {
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		ObjectOutput out = null;
		try {
			out = new ObjectOutputStream(bos);   
			out.writeObject(object);
			out.flush();
			return bos.toByteArray();
		} catch (IOException ex) {
			throw ex;
		} finally {
			try {
				if(out != null)
					out.close();
			} catch (IOException ex) { }
		}
	}
	
	public static Object DeserializeObject(byte[] byteArray) throws IOException, ClassNotFoundException {
		if(byteArray == null)
			return null;
		
		ByteArrayInputStream bis = new ByteArrayInputStream(byteArray);
		ObjectInput in = null;
		try {
			in = new ObjectInputStream(bis);   
			return in.readObject();
		} catch (IOException | ClassNotFoundException ex) {
			throw ex;
		} finally {
			try {
				if(in != null)
					in.close();
			} catch (IOException ex) { }
		}
	}
	
	public static boolean IsValidOIB(String oib) {
		if (oib.length() != 11)
			return false;
		
		int znamenka;
		int zbroj;
		int medjuOstatak;
		int ostatak = 10;
		int umnozak;

		try {
			for (int charIndex = 0; charIndex < oib.length() - 1; charIndex++){
				znamenka = Integer.parseInt(oib.substring(charIndex, charIndex + 1));
				zbroj = znamenka + ostatak;
				medjuOstatak = zbroj % 10;
				if (medjuOstatak == 0)
					medjuOstatak = 10;
				umnozak = medjuOstatak * 2;
				ostatak = umnozak % 11;
			}

			int kontrolniBroj = 11 - ostatak;
			if(kontrolniBroj == 10){
				kontrolniBroj = 0;
			}
			
			if (!oib.substring(oib.length() - 1, oib.length()).equals(String.valueOf(kontrolniBroj)))
				return false;
		} catch	(Exception ex){
			return false;
		}
		
		return true;
	}
	
	public static void CloseSocket(Socket socket, ObjectOutputStream oos, ObjectInputStream ois){
		try { socket.close(); } catch (Exception ex1) {}
		try { oos.close(); } catch (Exception ex1) {}
		try { ois.close(); } catch (Exception ex1) {}
	}
}
